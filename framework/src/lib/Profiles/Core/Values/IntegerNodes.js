"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LessThanOrEqual = exports.LessThan = exports.GreaterThanOrEqual = exports.GreaterThan = exports.Equal = exports.Sign = exports.Abs = exports.Clamp = exports.Max = exports.Min = exports.ToFloat = exports.Modulus = exports.Divide = exports.Multiply = exports.Negate = exports.Subtract = exports.Add = exports.Constant = void 0;
const NodeDescription_js_1 = require("../../../Nodes/NodeDescription.js");
const In1Out1FuncNode_js_1 = require("../../../Nodes/Templates/In1Out1FuncNode.js");
const In2Out1FuncNode_js_1 = require("../../../Nodes/Templates/In2Out1FuncNode.js");
const In3Out1FuncNode_js_1 = require("../../../Nodes/Templates/In3Out1FuncNode.js");
// Unreal Engine Integer Blueprints API: https://docs.unrealengine.com/4.27/en-US/BlueprintAPI/Math/Integer/
exports.Constant = new NodeDescription_js_1.NodeDescription('math/integer', 'Logic', 'Constant', (description, graph) => new In1Out1FuncNode_js_1.In1Out1FuncNode(description, graph, ['integer'], 'integer', (a) => a));
exports.Add = new NodeDescription_js_1.NodeDescription('math/add/integer', 'Logic', '+', (description, graph) => new In2Out1FuncNode_js_1.In2Out1FuncNode(description, graph, ['integer', 'integer'], 'integer', (a, b) => a + b));
exports.Subtract = new NodeDescription_js_1.NodeDescription('math/subtract/integer', 'Logic', '-', (description, graph) => new In2Out1FuncNode_js_1.In2Out1FuncNode(description, graph, ['integer', 'integer'], 'integer', (a, b) => a - b));
exports.Negate = new NodeDescription_js_1.NodeDescription('math/negate/integer', 'Logic', '-', (description, graph) => new In1Out1FuncNode_js_1.In1Out1FuncNode(description, graph, ['integer'], 'integer', (a) => -a));
exports.Multiply = new NodeDescription_js_1.NodeDescription('math/multiply/integer', 'Logic', '×', (description, graph) => new In2Out1FuncNode_js_1.In2Out1FuncNode(description, graph, ['integer', 'integer'], 'integer', (a, b) => a * b));
exports.Divide = new NodeDescription_js_1.NodeDescription('math/divide/integer', 'Logic', '÷', (description, graph) => new In2Out1FuncNode_js_1.In2Out1FuncNode(description, graph, ['integer', 'integer'], 'integer', (a, b) => a / b));
exports.Modulus = new NodeDescription_js_1.NodeDescription('math/modulus/integer', 'Logic', 'MOD', (description, graph) => new In2Out1FuncNode_js_1.In2Out1FuncNode(description, graph, ['integer', 'integer'], 'integer', (a, b) => a % b));
exports.ToFloat = new NodeDescription_js_1.NodeDescription('math/toFloat/integer', 'Logic', 'To Float', (description, graph) => new In1Out1FuncNode_js_1.In1Out1FuncNode(description, graph, ['integer'], 'float', (a) => Number(a)));
exports.Min = new NodeDescription_js_1.NodeDescription('math/min/integer', 'Logic', 'MIN', (description, graph) => new In2Out1FuncNode_js_1.In2Out1FuncNode(description, graph, ['integer', 'integer'], 'integer', (a, b) => (a > b ? b : a)));
exports.Max = new NodeDescription_js_1.NodeDescription('math/max/integer', 'Logic', 'MAX', (description, graph) => new In2Out1FuncNode_js_1.In2Out1FuncNode(description, graph, ['integer', 'integer'], 'integer', (a, b) => (a > b ? a : b)));
exports.Clamp = new NodeDescription_js_1.NodeDescription('math/clamp/integer', 'Logic', 'CLAMP', (description, graph) => new In3Out1FuncNode_js_1.In3Out1FuncNode(description, graph, ['integer', 'integer', 'integer'], 'integer', (value, min, max) => value < min ? min : value > max ? max : value, ['value', 'min', 'max']));
exports.Abs = new NodeDescription_js_1.NodeDescription('math/abs/integer', 'Logic', 'ABS', (description, graph) => new In1Out1FuncNode_js_1.In1Out1FuncNode(description, graph, ['integer'], 'integer', (a) => (a < 0n ? -a : a)));
exports.Sign = new NodeDescription_js_1.NodeDescription('math/sign/integer', 'Logic', 'SIGN', (description, graph) => new In1Out1FuncNode_js_1.In1Out1FuncNode(description, graph, ['integer'], 'integer', (a) => (a < 0n ? -1n : a > 0n ? 1n : 0n)));
exports.Equal = new NodeDescription_js_1.NodeDescription('math/equal/integer', 'Logic', '=', (description, graph) => new In2Out1FuncNode_js_1.In2Out1FuncNode(description, graph, ['integer', 'integer'], 'boolean', (a, b) => a === b));
exports.GreaterThan = new NodeDescription_js_1.NodeDescription('math/greaterThan/integer', 'Logic', '>', (description, graph) => new In2Out1FuncNode_js_1.In2Out1FuncNode(description, graph, ['integer', 'integer'], 'boolean', (a, b) => a > b));
exports.GreaterThanOrEqual = new NodeDescription_js_1.NodeDescription('math/greaterThanOrEqual/integer', 'Logic', '≥', (description, graph) => new In2Out1FuncNode_js_1.In2Out1FuncNode(description, graph, ['integer', 'integer'], 'boolean', (a, b) => a >= b));
exports.LessThan = new NodeDescription_js_1.NodeDescription('math/lessThan/integer', 'Logic', '<', (description, graph) => new In2Out1FuncNode_js_1.In2Out1FuncNode(description, graph, ['integer', 'integer'], 'boolean', (a, b) => a < b));
exports.LessThanOrEqual = new NodeDescription_js_1.NodeDescription('math/lessThanOrEqual/integer', 'Logic', '≤', (description, graph) => new In2Out1FuncNode_js_1.In2Out1FuncNode(description, graph, ['integer', 'integer'], 'boolean', (a, b) => a <= b));
