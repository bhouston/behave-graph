"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Equal = exports.ColorToHex = exports.HexToColor = exports.ColorToHsl = exports.HslToColor = exports.Mix = exports.Scale = exports.Negate = exports.Subtract = exports.Add = exports.Elements = exports.Create = exports.Constant = void 0;
const NodeDescription_js_1 = require("../../../Nodes/NodeDescription.js");
const In1Out1FuncNode_js_1 = require("../../../Nodes/Templates/In1Out1FuncNode.js");
const In2Out1FuncNode_js_1 = require("../../../Nodes/Templates/In2Out1FuncNode.js");
const In3Out1FuncNode_js_1 = require("../../../Nodes/Templates/In3Out1FuncNode.js");
const VecElements_js_1 = require("../Logic/VecElements.js");
const Vec3_js_1 = require("./Internal/Vec3.js");
exports.Constant = new NodeDescription_js_1.NodeDescription('math/color', 'Logic', 'Constant', (description, graph) => new In1Out1FuncNode_js_1.In1Out1FuncNode(description, graph, ['color'], 'color', (a) => a));
exports.Create = new NodeDescription_js_1.NodeDescription('math/create/color', 'Logic', 'CREATE', (description, graph) => new In3Out1FuncNode_js_1.In3Out1FuncNode(description, graph, ['float', 'float', 'float'], 'color', (r, g, b) => new Vec3_js_1.Vec3(r, g, b), ['r', 'g', 'b']));
exports.Elements = new NodeDescription_js_1.NodeDescription('math/elements/color', 'Logic', 'CREATE', (description, graph) => new VecElements_js_1.VecElements(description, graph, 'color', ['r', 'g', 'b'], Vec3_js_1.vec3ToArray));
exports.Add = new NodeDescription_js_1.NodeDescription('math/add/color', 'Logic', '+', (description, graph) => new In2Out1FuncNode_js_1.In2Out1FuncNode(description, graph, ['color', 'color'], 'color', Vec3_js_1.vec3Add));
exports.Subtract = new NodeDescription_js_1.NodeDescription('math/subtract/color', 'Logic', '-', (description, graph) => new In2Out1FuncNode_js_1.In2Out1FuncNode(description, graph, ['color', 'color'], 'color', Vec3_js_1.vec3Subtract));
exports.Negate = new NodeDescription_js_1.NodeDescription('math/negate/color', 'Logic', '-', (description, graph) => new In1Out1FuncNode_js_1.In1Out1FuncNode(description, graph, ['color'], 'color', Vec3_js_1.vec3Negate));
exports.Scale = new NodeDescription_js_1.NodeDescription('math/scale/color', 'Logic', 'ร', (description, graph) => new In2Out1FuncNode_js_1.In2Out1FuncNode(description, graph, ['color', 'float'], 'color', Vec3_js_1.vec3Scale));
exports.Mix = new NodeDescription_js_1.NodeDescription('math/mix/color', 'Logic', 'รท', (description, graph) => new In3Out1FuncNode_js_1.In3Out1FuncNode(description, graph, ['color', 'color', 'float'], 'color', Vec3_js_1.vec3Mix, ['a', 'b', 't']));
exports.HslToColor = new NodeDescription_js_1.NodeDescription('math/ToColor/hsl', 'Logic', 'HSL to COLOR', (description, graph) => new In1Out1FuncNode_js_1.In1Out1FuncNode(description, graph, ['vec3'], 'color', Vec3_js_1.hslToRGB));
exports.ColorToHsl = new NodeDescription_js_1.NodeDescription('math/toHsl/color', 'Logic', 'COLOR to HSL', (description, graph) => new In1Out1FuncNode_js_1.In1Out1FuncNode(description, graph, ['color'], 'vec3', Vec3_js_1.rgbToHSL));
exports.HexToColor = new NodeDescription_js_1.NodeDescription('math/toColor/hex', 'Logic', 'HEX to COLOR', (description, graph) => new In1Out1FuncNode_js_1.In1Out1FuncNode(description, graph, ['float'], 'color', Vec3_js_1.hexToRGB));
exports.ColorToHex = new NodeDescription_js_1.NodeDescription('math/toHex/color', 'Logic', 'COLOR to HEX', (description, graph) => new In1Out1FuncNode_js_1.In1Out1FuncNode(description, graph, ['color'], 'float', Vec3_js_1.rgbToHex));
exports.Equal = new NodeDescription_js_1.NodeDescription('math/equal/color', 'Logic', '=', (description, graph) => new In2Out1FuncNode_js_1.In2Out1FuncNode(description, graph, ['color', 'color'], 'boolean', Vec3_js_1.vec3Equals));
